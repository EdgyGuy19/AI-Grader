{
  "user_id": "bhansing",
  "task": "task-12",
  "read_me": "# Time complexity\n\nThis week the focus is on determining the time complexity of algorithms. This is an important step forward into the theoretical side of computer science as well as having the ability to decide which algorithms are better in terms of their time complexity. Woohoo! Last assignment of the year :)\n\n### üíÄ Deadline\n\nThis work should be completed before the exercise on **Friday 6th December**.\n\n### üë©‚Äçüè´ Instructions\n\nFor instructions on how to do and submit the assignment, please see the\n[assignments section of the course instructions](https://gits-15.sys.kth.se/inda-24/course-instructions#assignments).\n\n### üìù Preparation\n\n- Review the [lecture slides](https://docs.google.com/presentation/d/1h30_64jBHo2vuZfSnjyN2uxz3_5_zfuU4usqGFjWfAI/edit#slide=id.p)\n- Read and answer all questions in [Module 3: Complexity](https://qbl.sys.kth.se/sections/dd1338_ht24_algorithms_and_dat/lesson/hyn0i_analysis_of_complexity_wfwr1)\n\nAn important part of each task is testing. We provide an almost complete test suite where relevant and you should use this to test your implementation. We also expect you to complete the test suite where test methods are incomplete. If you need a reminder of running unittests in Java, follow these guides:\n\n- [Running JUnit4 from the command line](https://gits-15.sys.kth.se/inda-24/course-instructions/blob/master/junit4_12_command_line.md)\n- [Using IntelliJ with JUnit4](https://www.youtube.com/watch?v=HU0Ittkjx4Y)\n- Using VS Code: Install the `Java Test Runner` extension within the app and follow the instructions.\n\n### ‚úÖ Learning Goals\n\n- Determine orders of growth of functions\n- Calculate running times in relation to growing problem sizes\n- Establish time complexity of functions\n- Find the basic operation of an iterative algorithm\n- Compare and contrast sorting algorithms in terms of their behaviour\n\n### üö® Troubleshooting Guide\n\nIf you have any questions or problems, follow this procedure: <br/>\n\n1. Look at this week's [posted issues](https://gits-15.sys.kth.se/inda-24/help/issues). Are other students asking about your problem?\n2. If not, post a question yourself by creating a [New Issue](https://gits-15.sys.kth.se/inda-24/help/issues/new). Add a descriptive title, beginning with \"Task *x*: *summary of problem here*\"\n3. Ask a TA in person during the [weekly lab](https://queue.csc.kth.se/Queue/INDA). Check your schedule to see when the next lab is.\n\nWe encourage you to discuss with your course friends, **but do not share answers!** Similarily, use of any AI services ü§ñ are great to help explain things, **but please do not submit AI-generated solutions** - you must be both responsible for your own solutions and must be able to explain them under examination.\n\n### üèõ Assignment\n\nGetting a feel for how algorithms respond to growing problem sizes is vital in helping you make better implementation choices. We can start with simple functions and explore what happens as we increase the problem size, in terms of the time taken or the amount of operations. Once we have established the complexity of multiple functions/algorithm, we can order them appropriately.\n\nPlease commit any Java code developed to the [`src`](src) folder and any\nwritten answers to the [`docs`](docs) folder.\n\n#### Exercise 12.1\n\nTo develop a sense of the relationship between problem size and an algorithm's\norder of growth, complete the table of running times below (we shall\npresume that time is the amount of nanoseconds).\n\n- Logarithmic = log<sub>2</sub>(n)\n- Linear = n\n- Linearithmic = n log n\n- Quadratic = n<sup>2</sup>\n- Cubic = n<sup>3</sup>\n- Exponential = 2<sup>n</sup>\n- Factorial = n!\n\nAssume that logarithms are base 2 when you see log n. Give n with 1-2\nsignificant digits. Also assume that the computer performs **1 operation per\nnanosecond**. The middle row has been given to act as guidance! For example a\nproblem size of 1000 and an algorithm with complexity n (linear growth) will\ntake 1000 nanoseconds to complete.\n\nUse [e-notation](https://en.wikipedia.org/wiki/Scientific_notation#E-notation)\nfor large values (e.g. `3e9` instead of `3*10^9` or `3000000000`)\n\nAbsolutely humongous numbers can be rounded off to infinity. Copy the html code\nfrom the 1 hour cell of `logn` in [Exercise 2](#exercise-2) if you want the\nactual symbol, or just write `inf`!\n\n| Size / complexity |     log n     |       n       |    n log n    |  n<sup>2</sup>   |  n<sup>3</sup>   |   2<sup>n</sup>  |      n!          |\n|-------------------|---------------|---------------|---------------|------------------|------------------|------------------|------------------|\n| 1                 |               |               |               |                  |                  |                  |                  |\n| 10                |               |               |               |                  |                  |                  |                  |\n| 100               |               |               |               |                  |                  |                  |                  |\n| 1000              | 9.97          | 1000          | 9966          | 1e6              | 1e9              | 1e301            | 4e2567           |\n| 10000             |               |               |               |                  |                  |                  |                  |\n| 100000            |               |               |               |                  |                  |                  |                  |\n| 1000000           |               |               |               |                  |                  |                  |                  |\n\n[Wolfram Alpha](https://www.wolframalpha.com) is an excellent calculator. For\nexample, `factorial(100)` will calculate `100!`, and `log2(1000)` will\ncalculate the base `n` logarithm of 1000 (e.g. replace `n` with `2` for\nbase 2).\n\n#### Exercise 12.2\n\nLet T(n) be the time in nanoseconds (1e-9 seconds) to solve a given problem of\nsize n with a certain algorithm. As before in [Exercise 1](#exercise-1), assume\nthat the computer performs **1 operation per nanosecond**.\n\nFor each function T(n) and for each time t in the table, give the largest value\nof n, for which the algorithm can solve the problem in time t. For example, if\nwe have an algorithm with linear complexity n, and one hour of time, then we can\nsimply count the number of nanoseconds to discover the problem size: 60 minutes * 60 seconds * 1e9 nanoseconds = 3.6e12.\n\nUse [e-notation](https://en.wikipedia.org/wiki/Scientific_notation#E-notation)\nfor large values (e.g. `3e9` instead of `3*10^9` or `3000000000`)\n\nAbsolutely humongous numbers can be rounded off to infinity. Copy the html code\nfrom the 1 hour cell of `logn` if you want the actual symbol, or just write\n`inf`!\n\n| T(n)          | 1 second | 1 minute |  1 hour  |  1 day   |  1 year  |\n| --------------|----------|----------|----------|----------|----------|\n| log n         |          |          | &#x221e; |          |          |\n| n             |          |          | 3.6e12   |          |          |\n| n log n       |          |          | 9.8e10   |          |          |\n| n<sup>2</sup> |          |          | 1.8e6    |          |          |\n| n<sup>3</sup> |          |          | 15326    |          |          |\n| 2<sup>n</sup> |          |          | 41       |          |          |\n| n!            |          |          | 15       |          |          |\n\n> **Assistant's note:** Solving for n in an equation on the form `n*log(n) = x`\n> is not possible arithmetically. For the mathematically inclined, the solution\n> is approximated by `n = e^W(x)`, where `W` is the\n> [Lambert W function](https://en.wikipedia.org/wiki/Lambert_W_function). For\n> the _less_ mathematically inclined (like this humble assistant), the\n> solution is given by typing `n*log2(n) = x, solve for n` into\n> [Wolfram Alpha](https://www.wolframalpha.com) :D.\n\n#### Exercise 12.3.1\n\nArrange the functions in the following list in ascending order based on their\nrate of growth. That is, the function f(n) should come before the function g(n)\nin the list if f(n) is O(g(n)).\n\nf1(n) = n<sup>1.5</sup>\n\nf2(n) = 10<sup>n</sup>\n\nf3(n) = n log n\n\nf4(n) = n + 100\n\nf5(n) = 2<sup>n</sup>\n\n#### Exercise 12.3.2\n\nFor each of the statements below, answer whether it is true or false. Give a brief explanation of how you came to this conclusion.\n\nn (n + 1) / 2 = O(n<sup>3</sup>)\n\nn (n + 1) / 2 = O(n<sup>2</sup>)\n\nn (n + 1) / 2 = Œò(n<sup>3</sup>)\n\nn (n + 1) / 2 = Œ©(n)\n\n#### Exercise 12.4\n\nGive a Œò (big theta) estimation, as a function of n, of the worst case time\ncomplexity of the following five loops:\n\n```\nAlgorithm Loop1(n):\n   a = 0\n   for i = 1 to n\n      a += i\n\nAlgorithm Loop2(n):\n   b = 1\n   for i = 1 to 4n\n      b++\n\nAlgorithm Loop3(n):\n   c = 1\n   for i = 1 to n^2\n      c--\n\nAlgorithm Loop4(n):\n   d = 5\n   for i = 1 to 3n\n      for j = 1 to i\n         d = d + j\n\nAlgorithm Loop5(n):\n   e = 5\n   for i = 1 to n^2\n      for j = 1 to i\n         e = e + j\n```\n\n#### Exercise 12.5\n\nExplain why (n+1)<sup>3</sup> is O(n<sup>3</sup>). Use the following\ndefinition: f(n) is O(g(n)) if there exists positive constants c and\nn<sub>0</sub> such that f(n) &le; c &times; g(n) for all n &ge; n<sub>0</sub>.\n\n#### Exercise 12.6.1\n\nThe following algorithm reverses a collection.  Answer the following:\n\n- What is the basic operation for this algorithm?\n- Describe the time complexity of this algorithm\n\n```python\nReverse (A):\n    # Input: an array A storing n elements.\n    # Output: the same array with the elements in reversed order.\n    for i = 1 to n-1\n       x = A[i]\n       for j = i down to 1\n           A[j] = A[j-1]\n       A[0] = x\n```\n\n#### Exercise 12.6.2\n\nDesign a linear time O(n) algorithm to reverse a collection and implement two\nversions in Java, the first with arrays and the second with lists.  \n\nYour implementation should count the number of basic operations to ensure that\nthe complexity is O(n) for a given collection of size n.\n\nPlease implement the two methods in the code skeleton in\n[`src/Reverse.java`](src/Reverse.java) (and don't forget to remove the\nexceptions that are currently thrown!). See the [Testing](#testing) section for\ninstructions on how to test your implementations.\n\n> **Assistant's requirement:** Both versions of `reversed` should return a\n> reversed _copy_ of the argument, and are _not_ allowed to mutate the\n> argument.\n\n#### Exercise 12.7\n\nInsertion Sort and Selection Sort have similar worst case runtime complexity\nO(n<sup>2</sup>).  Explain:\n\n- How they differ in best case (a sorted collection) and mostly sorted case in\n  terms of the runtime complexity of each algorithm, and\n- Which should be preferred as a sorting algorithm with justification.\n\n### Testing\n\nFor this week's testing, you have been provided with a test skeleton with\nimplementations of tests for `Reverse.reversed(int[])`. Read through\nthe tests and make sure you understand what they do, and then implement\nall of the tests for `Reverse.reversed(List<Integer>)`. The test class\nis located in [`src/ReverseTest.java`](src/ReverseTest.java).\nAs usual, all of the tests that you need to implement hava a _fail_ statement\nin them that looks like this:\n\n```java\nfail(\"Not implemented!\");\n```\n\nRemove these and implement the tests!\n\nIf you need a reminder of running unittests in Java, follow these guides:\n\n- [Running JUnit4 from the command line](https://gits-15.sys.kth.se/inda-24/course-instructions/blob/master/junit4_12_command_line.md)\n- [Using IntelliJ with JUnit4](https://www.youtube.com/watch?v=HU0Ittkjx4Y)\n- Using VS Code: Install the `Java Test Runner` extension within the app and follow the instructions.\n\n### üôè Acknowledgment\n\nThis task was designed by:               <br>\nSimon Lars√©n                             <br>\nAnton Lyxell                             <br>\nStefan Nilsson                           <br>\nRic Glassey                              <br>\n",
  "source_files": [
    {
      "filename": "Reverse.java",
      "content": "import java.util.ArrayList;\nimport java.util.List;\n/**\n * A class for reversing List and array types.\n *\n * @author Buster Hansing\n * @version 2017-08-09\n */\npublic class Reverse {\n\n    /**\n     * Return a reversed copy of the argument array.\n     * The passed array is NOT mutated.\n     *\n     * @param array An array.\n     * @return A reversed copy of array.\n     */\n    public int[] reversed(int[] array) {\n        int[] reversedArray = new int[array.length];\n        int basicOperations = 0;\n\n        int n = array.length;\n        for (int i = 0; i < n; i++) {\n            reversedArray[i] = array[n - i - 1];\n            basicOperations++;\n        }\n\n        System.out.println(\"Basic operations: \" + basicOperations);\n        return reversedArray;\n    }\n\n    /**\n     * Return a reversed copy of the argument List.\n     * The passed List is NOT mutated.\n     *\n     * @param list A List.\n     * @return A reversed copy of list.\n     */\n    public List<Integer> reversed(List<Integer> list) {\n        List<Integer> reversedList = new ArrayList<>(list.size());\n        int basicOperations = 0;\n\n        int n = list.size();\n        for (int i = n - 1; i >= 0; i--) {\n            reversedList.add(list.get(i));\n            basicOperations++;\n        }\n\n        System.out.println(\"Basic operations: \" + basicOperations);\n        return reversedList;\n    }\n}\n"
    }
  ],
  "test_results": "JUnit version 4.12\n.Basic operations: 9\nBasic operations: 6\n.Basic operations: 1\n.Basic operations: 6\nBasic operations: 9\n.Basic operations: 6\nBasic operations: 9\n.Basic operations: 9\nBasic operations: 6\n.Basic operations: 9\nBasic operations: 6\n.Basic operations: 0\n.Basic operations: 0\n.Basic operations: 9\nBasic operations: 6\n.Basic operations: 1\n\nTime: 0.014\n\nOK (10 tests)\n\n\n"
}
